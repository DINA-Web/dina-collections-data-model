# DINA collections data model: design principles and documentation

## This document

The objective of this document is to describe the basic setup and design principles for the DINA collections data model. The primary target audience is database and system developers of the DINA system. It is a living documentation that should be updated according to the decisions within the team developing the DINA collections data model.

## Purpose of the DINA collections data model

The purpose of the DINA collections data model is to store information about natural history collections for the DINA information management system.

## Schema setup

- **Schema name:** dina_collections

- **Database management system:** MySQL

- **Default collation:** utf8\_general\_ci

- **Storage engine:** InnoDB

- **Default language:** English

- **Repository for ddl:** dina-collections-data-model

- **Database schema tracking:** Liquibase or a similar tracking tool should be used when real data is added to the system.

## General design principles

### Use numeric surrogate primary keys generated by the system
Numeric surrogate keys (unique values with no intrinsic meaning) should be used as primary keys in every table. The primary key values should be assigned by the database. All primary keys are defined as unique across the system.

### Use documented and approved domain database objects

Tables and attributes related to the domain should be documented and approved before they are used in the database.

### Add default fields to each table

Default fields to be used are:

- **version** - starting with 1

### Always use foreign key constraint option "restrict"

Foreign key constraints should be set to reference\_option "restrict", which means that it will not be possible to delete a row in the parent table without first removing the foreign key value in the child table.

### Do not use check constraints

Check constraints should not be used, validation should be in the application instead.

### Do not turn on indexing by default

Indexing should not be turned on for everything by default. Choice of indexes should be handled in schema-/model development procedures.

### Triggers, stored procedures and functions

A general discussion about where to keep the business logic should be held before starting to use triggers, stored procedures or functions.

## Naming conventions

We should use well-defined data object names so that we will not have to change them too much in the future, to avoid breaking dependencies.

### Use lowercase and underscore

Write all object names in lowercase alphanumeric characters and use underscore "_" to separate words.

#### Pattern

[word 1]\_[word 2]

#### Examples

"catalog\_number", "taxon", "preparation", "event\_field\_number"

### Use singular English names in present tense

Every object should have a singular English name and be in present tense.

#### Examples

"person", not "persons"  or "people", "information\_source", not "information\_sources"

### Never use reserved words

Do not use words that are reserved in:

- ANSI SQL 92

- ANSI SQL 99

- MySQL 3.23.x

- MySQL 4.x

- MySQL 5.x

- PostGreSQL 8.1

- MS SQL Server 2000

- MS ODBC

### Use full words, not abbreviations

Abbreviations should not be used, except for the most obvious. If you are in doubt, you should use the full English word.

### Avoid using prefixes/suffixes

Standard prefixes or suffixes should not be used to identify object types such as tables and columns.

### Use explicit naming

You should explicitly name each object. Default system-generated names are only acceptable if they are following the naming conventions in this document.

### Use "id" for primary keys

"id" should be used as the name of primary key fields.

### Combine relation type, parent table and referenced field for foreign keys

Foreign key field names should be a combination of the relation type, the referenced table and the name of the referenced field. An exception to this is is-a- relations where the foreign key should be named with just the referenced table and the id

#### Pattern

**Normally:** [relation type]\_[parent table name]\_id

**Is-a relations:** [parent table name]\_id

#### Example

collector\_agent\_id

### Combine table name, "\_ix\_" and column names for indexes

Index names should include both the table name and the column name(s). Table and first column should be separated by "\_ix\_"

#### Pattern

[table name]\_ix\_[first column name]\_[second column name]â€¦

#### Example

person\_ix\_first\_name\_last\_name

### Name all constraints explicitly

Constraints should be explicitly named. Every constraint name must be unique. Constraints should have a standardized prefix (the exception to the no-prefix rule).

#### Pattern

**Primary key constraints:** pk\_[table name]

**Foreign key constraints:** fk\_[table name]

**Default constraints:** df\_[table name]\_[field name]
